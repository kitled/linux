# Names

> [!Tip]
> TL;DR:
> - [`/dev/disk/by-id`](#by-id-serialwwn) for disks (serial is useful for maintenance)
> - [`/dev/disk/by-partlabel`](#by-partlabel) for partitions (easy & reliable)


## Persistent block device naming

https://wiki.archlinux.org/title/Persistent_block_device_naming

There are four different schemes used for persistent naming by [`udev`](https://wiki.archlinux.org/title/Udev) (through 60-persistent-storage.rules): [`by-label`](https://wiki.archlinux.org/title/Persistent_block_device_naming#by-label), [`by-uuid`](https://wiki.archlinux.org/title/Persistent_block_device_naming#by-uuid), [`by-id and by-path`](https://wiki.archlinux.org/title/Persistent_block_device_naming#by-id_and_by-path).  
For those using disks with GUID Partition Table (GPT), two additional schemes can be used `by-partlabel` and `by-partuuid`.

> [!Tip]
> Once you have identified your disks/partitions, `export` your specific `<ids>` to environment variables to simplify shell commands (`zpool`, `mdadm`, â€¦) referencing those block devices.
> 
> ```sh
> # Disks
> DISK_1='/dev/disk/by-id/nvme-Samsung_SSD_990_PRO_1TB_P2GKFC8E811407S'
> DISK_2='/dev/disk/by-id/nvme-Samsung_SSD_990_PRO_1TB_P2GKFC8E811580F'
> DISK_3='/dev/disk/by-id/nvme-Samsung_SSD_990_PRO_1TB_P2GKFC8E811584D'
> 
> export DISK_1 DISK_2 DISK_3
> 
> ZFS_DISKS=(
> $DISK_1
> $DISK_2
> $DISK_3
> )
> 
> export ZFS_DISKS
> ```
>
> For instance, place those in `$ZSH_CUSTOM/env.zsh` then run `omz reload` (with Zsh + Oh-My-Zsh).




### `by-id` (serial|WWN)

> [!Tip]
> Recommend for disks.

https://wiki.archlinux.org/title/Persistent_block_device_naming#by-id_and_by-path

`by-id` creates a unique name depending on the hardware serial number.

`by-id` also creates [**World Wide Name (WWN)**](https://en.wikipedia.org/wiki/World_Wide_Name) links of storage devices that support it.

SATA and SAS devices have a `wwn-` prefix while NVMe devices use a [different WWN format](https://en.wikipedia.org/wiki/World_Wide_Name#Formats) and are prefixed with `nvme-eui`.

> [!Note]
> `by-id` and `by-path` links can only be considered persistent for disks, not partitions. Partitions will be referenced by their number in the partition table and that can change if the partitions are reordered.

```sh
ls -l /dev/disk/by-id/
```




### `by-partlabel`

> [!Tip]
> Recommend for partitions.

https://wiki.archlinux.org/title/Persistent_block_device_naming#by-partlabel

GPT partition labels can be defined in the header of the [partition entry](https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_entries_.28LBA_2.E2.80.9333.29) on GPT disks.

This method is very similar to the [filesystem labels](https://wiki.archlinux.org/title/Persistent_block_device_naming#by-label), except the partition labels do not get affected if the file system on the partition is changed.

All partitions that have partition labels are listed in the `/dev/disk/by-partlabel` directory.

```sh
ls -l /dev/disk/by-partlabel/
```

The partition label of a device can be obtained with `lsblk`:

```sh
lsblk -dno PARTLABEL /dev/sda1
```

Or with `blkid`:

```
sudo blkid -s PARTLABEL -o value /dev/sda1
```




### `by-uuid`

https://wiki.archlinux.org/title/Persistent_block_device_naming#by-uuid

[UUID](https://en.wikipedia.org/wiki/UUID) is a mechanism to give each [filesystem](https://wiki.archlinux.org/title/Filesystem) a unique identifier. These identifiers are generated by filesystem utilities (e.g. `mkfs.*`) when the device gets formatted and are designed so that collisions are unlikely. All GNU/Linux filesystems (including swap and LUKS headers of raw encrypted devices) support UUID. FAT, exFAT and NTFS filesystems do not support UUID, but are still listed in `/dev/disk/by-uuid/` with a shorter UID (unique identifier):

```sh
ls -l /dev/disk/by-uuid/
```

The UUID of a device can be obtained with `lsblk`:

```sh
lsblk -dno UUID /dev/sda1
```

Or with `blkid`:

```sh
sudo blkid -s UUID -o value /dev/sda1
```

The advantage of using the UUID method is that it is much less likely that name collisions occur than with labels. Further, it is generated automatically on creation of the filesystem. It will, for example, stay unique even if the device is plugged into another system (which may perhaps have a device with the same label).

The disadvantage is that UUIDs make long code lines hard to read and break formatting in many configuration files (e.g. [`fstab`](https://wiki.archlinux.org/title/Fstab) or [`crypttab`](https://wiki.archlinux.org/title/Crypttab)). Also every time a volume is reformatted a new UUID is generated and configuration files have to get manually adjusted.





